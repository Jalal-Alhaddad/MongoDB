# Optimizing MongoDB

## 1. MongoDB Data Types

MongoDB stores data in **BSON**, a binary-encoded serialization format that supports richer data types than JSON. Common BSON types include:

- **String**, **Int32**, **Int64 (Long)**, **Double** (for floating-point numbers)
- **Boolean**, **Null**, **Date**, **Timestamp**
- **ObjectId**, **Array**, **Embedded Document**, **Regular Expression**, **Binary Data**, **Decimal128** (high-precision decimal) :contentReference[oaicite:0]{index=0}

These types allow efficient storage and querying of diverse data, including dates and binary payloads, which JSON cannot natively represent.

---

## 2. Scaling: Horizontal vs Vertical

| Scaling Type        | Description |
|---------------------|-------------|
| **Vertical Scaling** (Scaling Up) | Increase resources (CPU, RAM, storage) of a single server. Simple but has hardware limits and may cause downtime. :contentReference[oaicite:1]{index=1} |
| **Horizontal Scaling** (Scaling Out) | Distribute data across multiple servers using **sharding**. More complex yet cost-effective and scalable, with minimal downtime. :contentReference[oaicite:2]{index=2} |

---

## 3. Partitioning Concepts

### Horizontal Partitioning (Sharding)

Distributes data by splitting on a **shard key** so different documents go to different shards (servers). Ensures scalability and fault tolerance. :contentReference[oaicite:3]{index=3}

### Vertical Partitioning

Splits a document or collection by columns/fields (e.g., large, seldom-used fields separated out) to optimize performance and reduce unnecessary data retrieval. :contentReference[oaicite:4]{index=4}

---

## 4. Partition Key & Sort Key

- **Partition (Shard) Key**: Determines document distribution. Should be chosen to ensure even load distribution, minimize cross-shard operations, and align with query patterns. E.g., user ID or date-based range. :contentReference[oaicite:5]{index=5}

- **Sort Key**: Used to order query results effectively. Should align with frequent query patterns (e.g., sort by timestamp for time-series data), and often leveraged within compound indexes.

---

## 5. Time-To-Live (TTL) Index

A **TTL index** automatically deletes documents after a specified duration. Ideal for caching, logging, session data, or any data that expires. You define a TTL on a **date field**; MongoDB periodically removes expired documents per that timeline.

---

## 6. Storage Requirements & Throughput Planning

### Assess Storage Needs

Consider data volume, document size, indexing overhead, and retention policies (e.g., with TTL). BSON documents have a 16MB size limit. :contentReference[oaicite:6]{index=6}

### Throughput (Read / Write) Planning

Estimate:

- Concurrent read/write requests per second
- Required responsiveness
- Data growth rate

Map these needs to cluster sizing, number of shards, replica setups, and read/write capacity on MongoDB Atlas or equivalent.

---

## 7. Indexing for Query Optimization

Proper indexing significantly improves query performance:

- **Single-Field Indexes**: For specific frequent filters.
- **Compound Indexes**: Combine multiple fields; useful if your queries filter and sort on those fields together.
- Design indexes that match query shapes and sort patterns to enable index-only retrieval.

---

## 8. Putting It All Together: A Practical Example

**Use Case**: Logging events from a mobile app (e.g., for session analytics).

1. **Collection**: `appLogs`
2. **Data Fields**:
   - `_id`: ObjectId
   - `userId`: String
   - `eventType`: String
   - `timestamp`: Date
   - `details`: Embedded document

3. **Partition Key**: `userId` (hashed) — distributes load evenly across shards.
4. **Indexes**:
   - TTL index on `timestamp` for auto-deletion after e.g., 30 days.
   - Compound index on `{ userId: 1, timestamp: -1 }` for fast retrieval of recent events per user.
5. **Throughput & Storage Planning**:
   - Estimate number of users × events/day → data volume → shards needed.
   - Use replica sets for high availability.
   - Monitor and scale shards based on load.

---

### Summary

This equips you with:

- Deeper understanding of MongoDB's BSON data types
- Differentiation of scaling strategies
- Techniques for partitioning and choosing appropriate keys
- TTL indexing and automated data lifecycle management
- Planning data storage and throughput capacity
- Building effective indexes to meet query performance needs

These concepts are especially vital in mobile app backends, where flexible, scalable, and efficient data handling is essential.

---
